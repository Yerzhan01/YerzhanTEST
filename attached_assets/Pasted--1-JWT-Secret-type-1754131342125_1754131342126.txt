# Рекомендации по улучшению проекта

## 1. Безопасность и производительность

### JWT Secret
```typescript
// Сейчас в server/routes.ts:
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";

// Рекомендация: обязательная проверка
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  throw new Error("JWT_SECRET must be set in environment variables");
}
```

### Rate Limiting
```typescript
import rateLimit from 'express-rate-limit';

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 5, // максимум 5 попыток входа
  message: 'Too many login attempts, try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/auth/login', authLimiter);
```

## 2. Улучшения UX

### Загрузка данных
```typescript
// В компонентах добавить Skeleton загрузки
{isLoading ? (
  <div className="space-y-4">
    {Array.from({ length: 5 }).map((_, i) => (
      <Skeleton key={i} className="h-16 w-full" />
    ))}
  </div>
) : (
  // ... контент
)}
```

### Оптимистичные обновления
```typescript
const updateDealMutation = useMutation({
  mutationFn: updateDeal,
  onMutate: async (newDeal) => {
    // Отменяем исходящие запросы
    await queryClient.cancelQueries(['deals']);
    
    // Сохраняем предыдущее состояние
    const previousDeals = queryClient.getQueryData(['deals']);
    
    // Оптимистично обновляем
    queryClient.setQueryData(['deals'], (old) => 
      old?.map(deal => deal.id === newDeal.id ? newDeal : deal)
    );
    
    return { previousDeals };
  },
  onError: (err, newDeal, context) => {
    // Откатываем при ошибке
    queryClient.setQueryData(['deals'], context?.previousDeals);
  }
});
```

## 3. Мониторинг и логирование

### Structured Logging
```typescript
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// Использование:
logger.info('User login', { userId, username, ip: req.ip });
logger.error('Database error', { error: err.message, stack: err.stack });
```

### Health Check Endpoint
```typescript
app.get('/health', async (req, res) => {
  try {
    // Проверяем подключение к БД
    await db.select().from(users).limit(1);
    
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      database: 'connected'
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});
```

## 4. Тестирование

### Unit Tests для утилит
```typescript
// client/src/utils/__tests__/api.test.ts
import { fetchWithAuth } from '../api';

describe('fetchWithAuth', () => {
  it('should include auth token in headers', async () => {
    localStorage.setItem('auth_token', 'test-token');
    
    const mockFetch = jest.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: 'test' })
    });
    global.fetch = mockFetch;
    
    await fetchWithAuth('/api/test');
    
    expect(mockFetch).toHaveBeenCalledWith('/api/test', {
      headers: {
        'Authorization': 'Bearer test-token',
        'Content-Type': 'application/json'
      }
    });
  });
});
```

### API Integration Tests
```typescript
// server/__tests__/auth.test.ts
import request from 'supertest';
import { app } from '../index';

describe('Authentication', () => {
  it('should login with valid credentials', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        username: 'testuser',
        password: 'testpass'
      });
    
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('token');
    expect(response.body).toHaveProperty('user');
  });
});
```

## 5. Производительность

### Database Connection Pooling (уже настроено ✅)
```typescript
// server/db.ts - уже хорошо настроено
export const pool = new Pool({ 
  connectionString: process.env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
  allowExitOnIdle: true
});
```

### Кэширование запросов
```typescript
// Добавить Redis для кэширования
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// Middleware для кэширования
const cache = (duration = 300) => async (req, res, next) => {
  const key = `cache:${req.originalUrl}`;
  const cached = await redis.get(key);
  
  if (cached) {
    return res.json(JSON.parse(cached));
  }
  
  res.sendResponse = res.json;
  res.json = (body) => {
    redis.setex(key, duration, JSON.stringify(body));
    res.sendResponse(body);
  };
  
  next();
};

// Использование:
app.get('/api/analytics/dashboard', cache(60), handler);
```

## 6. Обработка ошибок

### Глобальный Error Handler
```typescript
// server/middleware/errorHandler.ts
export const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {
  logger.error('Unhandled error', {
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  if (err.name === 'ValidationError') {
    return res.status(400).json({
      message: 'Validation failed',
      details: err.message
    });
  }

  if (err.name === 'UnauthorizedError') {
    return res.status(401).json({
      message: 'Authentication required'
    });
  }

  res.status(500).json({
    message: 'Internal server error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};

// В index.ts:
app.use(errorHandler);
```

### Retry Logic на фронтенде
```typescript
// hooks/useRetryQuery.ts
export const useRetryQuery = (queryKey: string[], queryFn: QueryFunction) => {
  return useQuery({
    queryKey,
    queryFn,
    retry: (failureCount, error) => {
      if (error?.status === 401) return false; // Не повторять для auth ошибок
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)
  });
};
```

## 7. SEO и метаданные

### Dynamic Page Titles
```typescript
// hooks/usePageTitle.ts
export const usePageTitle = (title: string) => {
  useEffect(() => {
    const prevTitle = document.title;
    document.title = `${title} | Платформа продаж`;
    
    return () => {
      document.title = prevTitle;
    };
  }, [title]);
};

// В компонентах:
export default function Dashboard() {
  usePageTitle('Дашборд');
  // ...
}
```

## 8. Документация API

### OpenAPI/Swagger
```typescript
import swaggerJsdoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Sales Platform API',
      version: '1.0.0',
      description: 'API для платформы управления продажами'
    },
  },
  apis: ['./server/routes.ts'],
};

const specs = swaggerJsdoc(options);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));

/**
 * @swagger
 * /api/deals:
 *   get:
 *     summary: Получить список сделок
 *     tags: [Deals]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *         description: Номер страницы
 *     responses:
 *       200:
 *         description: Список сделок
 */
```

## Приоритет внедрения

1. **Высокий приоритет:**
   - JWT_SECRET проверка
   - Rate limiting для авторизации
   - Structured logging
   - Health check endpoint

2. **Средний приоритет:**
   - Unit/Integration тесты
   - Оптимистичные обновления
   - Error boundaries на фронтенде

3. **Низкий приоритет:**
   - Redis кэширование
   - OpenAPI документация
   - Advanced monitoring